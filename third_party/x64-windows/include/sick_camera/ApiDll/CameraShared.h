/**	@file	CameraShared.h
*
*	@copyright	Copyright 2016-2020 SICK AG. All rights reserved.
*	@author		Vision Lab, SICK GCN
*
*/

#pragma once

#include "Typedef.h"
#include "CustomerLog.h"
#include "ImageTable.h"
#include "Parameters.h"
#include "DeviceConnection.h"
#include "Version.h"

#ifdef CALLBACK_NEW
#include <thread>
#include <mutex>
#endif

#define Need_m_openInterfaces

namespace SickCam
{
class Ranger3;
class Trispector;

typedef std::map<Str, SPtr<DeviceConnection>> deviceList;

/**
* @brief CameraShared 是 Ranger3 和 Trispector 运行的共享基础环境。 \n\n
* 请确保指定 cti 文件路径，或将其和 exe 文件处于同一文件夹内。\n
* cti 文件是二进制文件，其作用类似于dll，是基础程序集的一部分，由 SICK-IVP 提供。 \n\n
* \n
* CameraShared is the environment shared by Ranger3s and Trispectors.
* CTI file should be in the same folder with exe. The cti is a binary file generated by IVP, which is a API library.
* \n
* @param [in] logPath	日志文件路径，设为""则不生成日志。	The log file path. if it sets to "", no using log.
* @param [in] ctiPath	cti 文件路径，不可为空。			The cti file path.
* @param [in] enShow	true 则输出日志内容到命令行。  true means to print log to CMD.
* @param [in] enWrite	true 则输出日志内容到文件。    true means to print log to file.
* \n
* @note 构造函数的基本动作包括\n
* - 1. 设定该程序的最高优先级，保证在被 CPU 执行期间不受干扰。\n
* - 2. 加载日志。 \n
* - 3. 加载 cti 文件。\n
* scanDevice() 将会被构造函数调用，用于扫描所有已连接到电脑的设备。\n
* \n
* Construction processes include :\n
* - 1. Set thread priority as highest. \n
* - 2. Load log file. \n
* - 3. Load cti file, The default searching folder is exe-folder. \n
* scanDevice() will be called by ctor to scan all device connected to PC.
*/
class CameraShared final
{
public:

	/**
	* @brief 请确保 cti 文件和 exe 文件处于同一文件夹内。cti 文件是二进制文件，其作用类似于dll，是基础程序集的一部分，由 SICK-IVP 提供。 \n\n
	* CTI file should be in the same folder with exe. The cti is a binary file generated by IVP, which is a API library.
	*
	* @param [in] logPath	日志文件路径，设为""则不生成日志。	The log file path. if it sets to "", no using log.
	* @param [in] ctiPath	cti 文件路径，不可为空。			The cti file path.
	* @param [in] enShow	true 则输出日志内容到命令行。  true means to print log to CMD. 
	* @param [in] enWrite	true 则输出日志内容到文件。    true means to print log to file.
	*
	* @note 构造函数的基本动作包括\n
	* - 1. 设定该程序的最高优先级，保证在被 CPU 执行期间不受干扰。\n
	* - 2. 加载日志。 \n
	* - 3. 加载 cti 文件。\n
	* - 4. 该类在使用中应该保持单例，线程不安全。 \n
	* scanDevice() 将会被构造函数调用，用于扫描所有已连接到电脑的设备。\n
	* \n
	* Construction processes include :\n
	* - 1. Set thread priority as highest. \n
	* - 2. Load log file. \n
	* - 3. Load cti file, The default searching folder is exe-folder. \n
	* scanDevice() will be called by ctor to scan all device connected to PC. 
	*/
	EXPORT_TO_DLL CameraShared( cStr& logPath, 
								cStr& ctiPath="", 
								const bool enShow = true,
								const bool enWrite = true);
	EXPORT_TO_DLL ~CameraShared();

	/** 
	* @brief 获取连接到电脑的设备名列表，以及设备对象指针。\n \n
	* To get the ptr map of devices. 
	* 
	* @return std::map<device_name_string, device_ptr>
	*/
	EXPORT_TO_DLL const deviceList  	getConDevList	(bool available_device_only = false)	const;

	/** 
	* @brief 获取连接到电脑的设备IP列表，以及设备对象指针。  \n\n
	* To get the ptr map of devices, marked with IP.
	*
	* @note Invalid of trispector
	*
	* @return std::map<device_IP_string, device_ptr>
	*/
	EXPORT_TO_DLL const deviceList 		getConDevListIP	(bool available_device_only = false)	const;
	
	/**
	* @brief 获取连接到电脑的设备IP列表，以及设备对象指针。  \n\n
	* To get the ptr map of devices, marked with MAC.
	*
	* @note Invalid of trispector
	*
	* @return std::map<device_MAC_string, device_ptr>
	*/
	EXPORT_TO_DLL const deviceList		getConDevListMAC(bool available_device_only = false)	const;
	
	/**
	* @brief 获取连接到电脑的设备IP列表，以及设备对象指针。  \n\n
	* To get the ptr map of devices, marked with SN.
	*
	* @note Invalid of Ranger3, Trispector only!
	*
	* @return std::map<device_MAC_string, device_ptr>
	*/
	EXPORT_TO_DLL const deviceList 		getConDevListSN(bool available_device_only = false)		const;

	/**
	* @brief 扫描连接到电脑的 GenICam 设备。\n\n
	* To scan all device connected to PC. 
	*
	* @param [in] numberDeviceNewFound	返回新找到的相机数量。注意，已经找到的不会被计算在内，这是【新】找到的设备数量。
	*
	* @return 
	* - ERROR_OPEN_TL_HANDLE	打开 GenTL 失败。	Can not open GenTL of GenICam. 
	* - All_OK					找到设备。			Found. 
	*/
	EXPORT_TO_DLL CAM_STATUS			scanDevice		(int&  numberDeviceNewFound);

	/**
	* @brief 扫描连接到电脑的 GenICam 设备。\n\n
	* To scan all device connected to PC. 
	*
	* @return 
	* - ERROR_OPEN_TL_HANDLE	打开 GenTL 失败。	Can not open GenTL of GenICam. 
	* - All_OK					找到设备。			Found. 
	*/
	EXPORT_TO_DLL CAM_STATUS			scanDevice		();

	/**
	* @brief 加载 cti 文件。 \n\n
	* To load cti file of given path.
	* 
	* @param [in] ctiPath	cti 文件路径。The cti file path. 
	*
	* @note cti 文件由 SICK AG 生成。此函数将在 ctor 中调用。如果 ( isCtiFound() == false && isAvaliable() == false )，
	* 请手动调用它并传递有效的 cti 文件路径。 \n
	* \n
	* The cti file is generated by SICK. This function will be called in ctor. 
	* If ( isCtiFound() == false && isAvaliable() == false ), please call it manually and passing valid cti file path.
	*
	* @return
	* - ERROR_OPEN_CONSUMER		打开 consumer 失败。Can not open consumer model of GenICam.
	* - All_OK					
	*/
	EXPORT_TO_DLL CAM_STATUS			loadCtiFile		(cStr& ctiPath);
	
	/**
	* @brief 获取初始化结果，检测 cti 文件 和 连接设备是否都存在。\n\n
	* To check initialization result. Check both CTI file and avaliable device
	*
	* @note 结果为：isCtiFound() && isDevFound();
	* @return
	* - true	OK. cti文件存在，并且找到连接设备。				Both CTI file and avaliable device found!
	* - false	未连接任何设备、设备未就绪或加载 cti 文件失败！	No device is connected, device is not ready or loading cti file failed!  
	*/
	EXPORT_TO_DLL bool					isAvaliable		()	const { return isCtiFound() && isDevFound(); };
	
	/**
	* @brief 获取 cti 文件导入结果。 \n\n
	* To check load cti result.
	*
	* @return
	* - true	OK.
	* - false	cti 文件路径无效，或者未指定。 
	*/
	EXPORT_TO_DLL bool					isCtiFound		()	const { return m_isCtiFound; };
	
	/**
	* @brief 获取设备扫描结果。\n\n
	* To check device scaning result. 
	*
	* @return
	* - true	OK.
	* - false	未连接任何设备、设备未就绪！ No device is connected, device is not ready! 
	*/
	EXPORT_TO_DLL bool					isDevFound		()	const { return m_isDevFound; };

	/**
	* @brief 是否输出运行日志到屏幕，控制台程序中有效。\n\n
	* Whether to print log in command line.
	*
	* @return
	* - true	Yes.
	* - false	No.
	*/
	EXPORT_TO_DLL bool					isLogOutput		()	const { return m_enableLogOutput; };
	
	/**
	* @brief 是否输出运行日志到文件。\n\n
	* Whether to save log to file.
	*
	* @return
	* - true	Yes.
	* - false	No.
	*/
	EXPORT_TO_DLL bool					isLogToFile		()	const { return m_enableLogWriteToFile; };

	EXPORT_TO_DLL std::string			getLastErrorMessage();
	EXPORT_TO_DLL std::string			getVersion() { return VER::version_number; };
	EXPORT_TO_DLL std::string			getVersionTime() { return VER::version_time; };
	/**
	* @brief 返回系统中安装的 CTI 文件路径。CTI 属于相机的底层文件，由 SICK 提供，默认路径将下面说明。\n\n
	* To return cti-file. 
	* \n	
	* \n
	* @note
	* 如有需要，可以不调用此函数，直接由用户给定 CTI 文件的路径。
	* - 对 Windows 用户：\n
	* --- 首先，查找环境变量 $(SICK_GENICAM_CTI)下是否有 SICKGigEVisionTL.cti 文件。\n
	* --- 如果没有，则会在 exe 文件所在路径查找 Ranger3 的 SICKGigEVisionTL.cti 文件。不过，在某些电脑上不能解析该路径，保险起见，可以直接给定 cti 文件的绝对路径。 \n
	* \n
	* - 对 Linux 用户：\n
	* --- 查找路径为： /usr/local/lib/sickGenTLProducer.cti \n
	* \n
	* \n
	* @return
	* - Absoluted path to cti. (SICKGigEVisionTL.cti)
	*/
	static EXPORT_TO_DLL std::string getPathToRanger3Producer();

#ifdef _WIN32
	/**
	* @brief 查找 CTI 文件路径。CTI 属于相机的底层文件，由 SICK 提供。\n\n
	* To find cti-file.
	* \n
	* \n
	* @note
	* - 对 Windows 用户：\n
	* --- 首先，查找环境变量 $(SICK_GENICAM_CTI)下是否有 SICKTrispectorTL64.cti 文件。\n
	* --- 如果没有，则会在 exe 文件所在路径查找 Trispector 的 SICKGigEVisionTL.cti 文件。不过，在某些电脑上不能解析该路径，保险起见，可以直接给定 cti 文件的绝对路径。 \n
	* \n
	* \n
	* @return
	* - Absoluted path to cti. (SICKTrispectorTL64.cti)
	*/
	static EXPORT_TO_DLL std::string getPathToTrispectorProducer();
#endif

protected:
	CameraShared() = delete;
	CameraShared(const CameraShared& r3s) = delete;
	CameraShared& operator = (const CameraShared& r3s) = delete;

	SPtr<SiConsumer>	getConsumer() const { return m_pconsumer; };

#ifdef __linux__
	GenTLApi *          getTL() { return m_pTl; };
#endif
#ifdef _WIN32
    SPtr<GenTLApi>      getTL() { return m_sTl; };
#endif

	CAM_STATUS			_scan_Device(int& numberDeviceNewFound);

    // if device lost, call this to remove its information
    void        _clear_invalid_device       (cStr& name);

    void        _scan_interface(cStr&               interfaceName,
                                GenTL::IF_HANDLE	interfaceHandle,
                                int &               nDevices);

	/** @brief It will skip the device already added*/
	void        _add_device		(cStr&               interfaceName,
								GenTL::IF_HANDLE	interfaceHandle,
								const SiDeviceList&	devices,
								const int64_t&		id,
								int &               nDevices);


    /**
    *	Make sure this application runs at the highest priority to ensure that
    *	all buffers can be recorded.
    */
	void _setProcessPriority();


	bool _clearR3S();
	bool _initLog(cStr& logPath);

	static bool _fileExists(const std::string & pathToFile);

private:
	static  bool is_Inited; // for Singleton 

	SPtr<SiConsumer>	m_pconsumer;
	deviceList			m_connectedDevices;		// very important, support r3 and trispector

	GenTL::TL_HANDLE	m_tlHandle=NULL; // base
	std::map<std::string, GenTL::TL_HANDLE>
	                    m_Interfaces_Map; // name, handle

	std::map<std::string, std::set<std::string>>
	                    m_Device_inInterface_Map; // interface_name, device_names


	bool				m_isCtiFound;
	bool				m_isDevFound;

    GenTLApi *          m_pTl=nullptr; // mostly for linux
    SPtr<GenTLApi>		m_sTl=nullptr; // only used for windows

	friend				Ranger3;
	friend				Trispector;

#ifdef CALLBACK_NEW
	std::mutex			m_mutex_scan;
#endif

public:
	SPtr<CustomerLog>	m_log;
	Str					m_logPath;
	bool				m_enableLogOutput;
	bool				m_enableLogWriteToFile;

};


}
